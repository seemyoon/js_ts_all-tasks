for (let i = 0; i < 5; i++) {
    setTimeout(() => {
        console.log(i)
    }, 1000)
}
for (var i = 0; i < 5; i++) {
    setTimeout(() => {
        console.log(i)
    }, 1000)
}


// VAR:
// Якщо код буде синхронним:
// Цикл йде: 0 → 1 → 2 → 3 → 4
// На кожній ітерації відразу викликається console.log(i)
// Значення i в момент виклику - свіже, поточне, тому все працює нормально (бо цикл йде синхронно, і на кожній ітерації значення змінної i перезаписується і стає актуальним на момент виведення)
//
// Результат:
// 0
// 1
// 2
// 3
// 4

// Якщо код буде асинхронний:
// Цикл швидко пробігає: 0 → 1 → 2 → 3 → 4 → 5
// Кожна setTimeout функція запам'ятовується, але виконується пізніше, через 1000 мс
// Коли ці функції починають працювати, змінна i вже = 5
// Всі вони дивляться на ту саму змінну i, тому що var — не створює нову змінну на кожну ітерацію
// Результат:
// 5
// 5
// 5
// 5
// 5
// це виглядатиме, якось так:
// setTimeout(() => {
//  console.log(5); // Перший колбек
// }, 1000);
//
// setTimeout(() => {
//  console.log(5); // Другий колбек
// }, 1000);
//
// setTimeout(() => {
//  console.log(5); // Третій колбек
// }, 1000);
//
// setTimeout(() => {
//  console.log(5); // Четвертий колбек
// }, 1000);
//
// setTimeout(() => {
//  console.log(5); // П'ятий колбек
// }, 1000);
// Всі вони виведуть 5, тому що всі колбеки посилаються на те саме значення змінної i.

// LET:
// Якщо код буде синхронним:
// Змінна i змінює своє значення кожної ітерації, і кожної ітерації виводиться поточне значення i.
// Результат:
// 0
// 1
// 2
// 3
// 4

// LET:
// Якщо код буде асинхронний:
// У кожній ітерації створюється своя окрема змінна i через область видимості let.
// setTimeout захоплює правильне значення i кожної ітерації.
// Результат:
// 0
// 1
// 2
// 3
// 4